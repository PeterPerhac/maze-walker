<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Maze Game with Textured Walls</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
<!-- Import Map -->
<script type="importmap">
   {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
        "three/examples/jsm/controls/PointerLockControls.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/PointerLockControls.js",
        "three/examples/jsm/loaders/SVGLoader.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/loaders/SVGLoader.js",
        "three/examples/jsm/utils/BufferGeometryUtils.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/utils/BufferGeometryUtils.js"
      }
    }



</script>

<!-- Main script -->
<script type="module">
    import * as THREE from 'three';
    import {PointerLockControls} from 'three/examples/jsm/controls/PointerLockControls.js';
    import {SVGLoader} from 'three/examples/jsm/loaders/SVGLoader.js';

    let scene, camera, renderer;
    let controls;
    let objects = [];

    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;

    let lottaLite = false;
    let collisionDetection = true;
    let superfast = false;
    let isWireframe = false;

    let prevTime = performance.now();
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const wallHeight = 10;
    const wallThickness = 0.5;
    const defaultSpeed = 200;
    const defaultLightRange = 25;
    const defaultBobbingSpeed = 20;
    const defaultBobbingAmount = 0.25;
    const defaultFogginess = 0.03;

    init();
    animate();

    function init() {
        // Create the scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Black background

        // Create the camera
        camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            1,
            1000
        );

        camera.position.set(0, wallHeight / 2 + 1, 150);

        // Set up controls
        controls = new PointerLockControls(camera, document.body);

        // Add controls to the scene
        scene.add(controls.getObject());

        // Add light (candle flame) to the controls object
        const light = new THREE.PointLight(0xffcc66, 1, defaultLightRange, 3);
        controls.getObject().add(light);

        const ambientLight = new THREE.AmbientLight(0xaa0000, 0.05);
        scene.add(ambientLight);

        const overheadSpotlight = new THREE.SpotLight(0x0066ff, 2, 150, Math.PI / 4, 0.5);
        overheadSpotlight.position.set(0, wallHeight * 3, -160);
        overheadSpotlight.target.position.set(0, 0, -140);
        scene.add(overheadSpotlight);
        scene.add(overheadSpotlight.target);

        const overheadSpotlight2 = new THREE.SpotLight(0x0066ff, 2, 150, Math.PI / 4, 0.5);
        overheadSpotlight2.position.set(0, wallHeight * 3, -120);
        overheadSpotlight2.target.position.set(0, 0, -140);
        scene.add(overheadSpotlight2);
        scene.add(overheadSpotlight2.target);
        // spotlightHelper = new THREE.SpotLightHelper(overheadSpotlight);
        // scene.add(spotlightHelper);


        scene.fog = new THREE.FogExp2(0x000000, defaultFogginess);


        // Create the renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);

        document.body.appendChild(renderer.domElement);

        // Load textures
        const textureLoader = new THREE.TextureLoader();

        // Floor texture
        const floorTexture = textureLoader.load('img/concrete.jpg');
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(100, 100); // Adjust repetition as needed
        floorTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        floorTexture.minFilter = THREE.LinearMipmapLinearFilter; // Enable mipmapping

        // Wall texture
        const wallTexture = textureLoader.load('img/wall.png');
        wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
        wallTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        wallTexture.minFilter = THREE.LinearMipmapLinearFilter; // Enable mipmapping

        // Create the floor
        const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
        const floorMaterial = new THREE.MeshPhongMaterial({map: floorTexture});
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Create the ceiling
        const ceilingGeometry = new THREE.PlaneGeometry(1000, 1000);
        const ceilingMaterial = new THREE.MeshPhongMaterial({map: floorTexture});
        const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.y = wallHeight;
        scene.add(ceiling);

        const outsideWallTexture = wallTexture.clone()
        outsideWallTexture.repeat.set(100, 1)

        // Create walls
        const outsideWallMaterial = new THREE.MeshPhongMaterial({map: outsideWallTexture});
        // Outer walls (boundary)
        createWall(0, wallHeight / 2, -500, 1000, wallHeight, wallThickness, outsideWallMaterial); // Front wall
        createWall(0, wallHeight / 2, 500, 1000, wallHeight, wallThickness, outsideWallMaterial);  // Back wall
        createWall(-500, wallHeight / 2, 0, wallThickness, wallHeight, 1000, outsideWallMaterial); // Left wall
        createWall(500, wallHeight / 2, 0, wallThickness, wallHeight, 1000, outsideWallMaterial);  // Right wall


        const pictureWallTexture = textureLoader.load('img/picture-wall.png');
        const tinaWallTexture = textureLoader.load('img/tina-wall.png');
        wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
        wallTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        wallTexture.minFilter = THREE.LinearMipmapLinearFilter; // Enable mipmapping

        const pictureWallMaterial = new THREE.MeshPhongMaterial({map: pictureWallTexture});
        const tinaPictureWallMaterial = new THREE.MeshPhongMaterial({map: tinaWallTexture});
        addMonument(pictureWallMaterial, tinaPictureWallMaterial, wallHeight);


        const loader = new SVGLoader();
        let geometries = [];
        loader.load(
            'mazes/big.svg',
            function (data) {
                const paths = data.paths;
                paths.forEach((path) => {
                    const color = path.userData.style.stroke;
                    if (color === '#ff0000' || color === 'red') return;
                    const shapes = SVGLoader.createShapes(path);
                    shapes.forEach((shape) => {
                        const points = shape.getPoints(2);
                        const p1 = points[0];
                        const p2 = points[1];

                        const dx = p2.x - p1.x;
                        const dz = p2.y - p1.y;
                        const length = Math.sqrt(dx * dx + dz * dz);
                        const angle = Math.atan2(dz, dx);

                        const geometry = new THREE.BoxGeometry(length, wallHeight, 1); // Scale as needed
                        const tex = wallTexture.clone();
                        tex.repeat.set(length/7.5, 2); // Adjust repetition as needed
                        const mat = new THREE.MeshPhongMaterial({map: tex});
                        const wall = new THREE.Mesh(geometry, mat);

                        wall.position.set(
                            (p1.x + p2.x) / 2 - 265,
                            wallHeight/2,
                            -(p1.y + p2.y) / 2 + 130
                        );
                        wall.rotation.y = -angle;
                        scene.add(wall);
                        objects.push(wall)
                    });
                });
            },
            function (xhr) {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            function (error) {
                console.error('Error loading SVG:', error);
            }
        );

        // Lock pointer on click
        document.addEventListener('click', function () {
            controls.lock();
        });

        // Movement controls
        const onKeyDown = function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
            }
        };

        const onKeyUp = function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;

                case 'Space':
                    lottaLite = !lottaLite;
                    break;
                case 'KeyC':
                    collisionDetection = !collisionDetection;
                    break;
                case 'KeyF':
                    superfast = !superfast;
                    bobbingSpeed = superfast ? 20 : defaultBobbingSpeed;
                    bobbingAmount = superfast ? 0.33 : defaultBobbingAmount;
                    break;
                case 'KeyM' :
                    isWireframe = !isWireframe;
                    scene.traverse(function (child) {
                        if (child.isMesh) {
                            child.material.wireframe = isWireframe;
                        }
                    });
                    break;
            }
        };

        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    let bobbingTime = 0; // Tracks bobbing progress
    let bobbingSpeed = defaultBobbingSpeed; // How fast the bobbing oscillates
    let bobbingAmount = defaultBobbingAmount; // How much the camera bobs


    function animate() {
        requestAnimationFrame(animate);
        // spotlightHelper.update();

        if (controls.isLocked === true) {
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            // Apply friction
            velocity.x -= velocity.x * 7.5 * delta;
            velocity.z -= velocity.z * 7.5 * delta;

            // Calculate movement direction
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize(); // Ensure consistent movement speed

            const speed = superfast ? 1000 : defaultSpeed;

            // Accelerate in the direction of movement
            if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

            // Save the old position
            const oldPosition = controls.getObject().position.clone();

            // Apply movement
            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            // Apply bobbing effect if moving
            bobbingTime += delta * bobbingSpeed;
            const bobbingOffset = Math.sin(bobbingTime) * bobbingAmount * (Math.min(velocity.length(), 8) / 8);
            controls.getObject().position.y = 2 + bobbingOffset; // 2 is the default height

            controls.getObject().children[0].distance = lottaLite ? 0 : defaultLightRange;
            scene.fog.density = lottaLite ? 0 : defaultFogginess;

            if (collisionDetection) {
                // Collision detection
                const cameraPosition = controls.getObject().position.clone();
                const collisionSphereRadius = 1.5; // Adjust as needed
                const sphere = new THREE.Sphere(cameraPosition, collisionSphereRadius);
                let collision = false;

                for (let i = 0; i < objects.length; i++) {
                    const boundingBox = new THREE.Box3().setFromObject(objects[i]);
                    if (boundingBox.intersectsSphere(sphere)) {
                        collision = true;
                        break;
                    }
                }

                if (collision) {
                    // Revert to the old position if collision detected
                    controls.getObject().position.copy(oldPosition);
                    velocity.set(0, 0, 0);
                }
            }
            prevTime = time;
        }

        renderer.render(scene, camera);
    }

    function createWall(x, y, z, width, height, depth, wallMaterial) {
        const wallGeometry = new THREE.BoxGeometry(width, height, depth);
        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
        wall.position.set(x, y, z);
        scene.add(wall);
        objects.push(wall);
    }

    function addMonument(material, tinaMaterial, height) {
        const wallThickness = 0.2;
        const wallLength = 10.0;
        const wall = new THREE.Mesh(new THREE.BoxGeometry(wallLength, height, wallThickness), material);
        const wall2 = new THREE.Mesh(new THREE.BoxGeometry(wallLength, height, wallThickness), tinaMaterial);
        wall.position.set(0, height / 2, -139.9);
        wall2.position.set(0, height / 2, -140.1);
        scene.add(wall);
        scene.add(wall2);
        objects.push(wall);
        objects.push(wall2);
    }
</script>
</body>
</html>
