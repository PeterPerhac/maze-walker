<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Maze Game with Textured Walls</title>
    <style>
        body { margin: 0; overflow: hidden; }
    </style>
</head>
<body>
<!-- Import Map -->
<script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js",
        "three/examples/jsm/controls/PointerLockControls.js": "https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/PointerLockControls.js"
      }
    }
    </script>

<!-- Main script -->
<script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/examples/jsm/controls/PointerLockControls.js';

    let scene, camera, renderer;
    let controls;
    let objects = [];

    let moveForward = false;
    let moveBackward = false;
    let moveLeft = false;
    let moveRight = false;

    let prevTime = performance.now();
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();

    init();
    animate();

    function init() {
        // Create the scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); // Black background

        // Create the camera
        camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            1,
            1000
        );

        // Set the initial camera position above the floor
        camera.position.set(0, 2, 0);

        // Set up controls
        controls = new PointerLockControls(camera, document.body);

        // Add controls to the scene
        scene.add(controls.getObject());

        // Add light (candle flame) to the controls object
        const light = new THREE.PointLight(0xff6600, 5, 50, 10); // Flame color and increased distance
        controls.getObject().add(light);

        // Create the renderer
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Load textures
        const textureLoader = new THREE.TextureLoader();

        // Floor texture
        const floorTexture = textureLoader.load('floor.png');
        floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
        floorTexture.repeat.set(40, 40); // Adjust repetition as needed
        floorTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        floorTexture.minFilter = THREE.LinearMipmapLinearFilter; // Enable mipmapping

        // Ceiling texture
        const ceilingTexture = textureLoader.load('ceiling.jpg');
        ceilingTexture.wrapS = ceilingTexture.wrapT = THREE.RepeatWrapping;
        ceilingTexture.repeat.set(20, 20); // Adjust repetition as needed
        ceilingTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        ceilingTexture.minFilter = THREE.LinearMipmapLinearFilter; // Enable mipmapping

        // Wall texture
        const wallTexture = textureLoader.load('wall.png');
        wallTexture.wrapS = wallTexture.wrapT = THREE.RepeatWrapping;
        wallTexture.repeat.set(5, 1); // Adjust repetition as needed
        wallTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        wallTexture.minFilter = THREE.LinearMipmapLinearFilter; // Enable mipmapping

        // Create the floor
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floorMaterial = new THREE.MeshPhongMaterial({ map: floorTexture });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Create the ceiling
        const ceilingGeometry = new THREE.PlaneGeometry(200, 200);
        const ceilingMaterial = new THREE.MeshPhongMaterial({ map: ceilingTexture });
        const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.y = 10; // Adjust to match wall height
        scene.add(ceiling);

        // Create walls
        const wallMaterial = new THREE.MeshPhongMaterial({ map: wallTexture });
        const wallThickness = 0.5;
        const wallHeight = 10;

        // Outer walls (boundary)
        createWall(0, wallHeight / 2, -100, 200, wallHeight, wallThickness, wallTexture); // Front wall
        createWall(0, wallHeight / 2, 100, 200, wallHeight, wallThickness, wallTexture);  // Back wall
        createWall(-100, wallHeight / 2, 0, wallThickness, wallHeight, 200, wallTexture); // Left wall
        createWall(100, wallHeight / 2, 0, wallThickness, wallHeight, 200, wallTexture);  // Right wall

        // Add random inner walls
        const wallCount = 30; // Number of random walls to add
        for (let i = 0; i < wallCount; i++) {
            addRandomWall(wallMaterial, wallHeight);
        }

        // Lock pointer on click
        document.addEventListener('click', function () {
            controls.lock();
        });

        // Movement controls
        const onKeyDown = function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
            }
        };

        const onKeyUp = function (event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
            }
        };

        document.addEventListener('keydown', onKeyDown, false);
        document.addEventListener('keyup', onKeyUp, false);

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        if (controls.isLocked === true) {
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            // Apply friction
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            // Calculate movement direction
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize(); // Ensure consistent movement speed

            const speed = 400.0;

            // Accelerate in the direction of movement
            if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
            if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

            // Save the old position
            const oldPosition = controls.getObject().position.clone();

            // Apply movement
            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            // Collision detection
            const cameraPosition = controls.getObject().position.clone();
            const collisionSphereRadius = 1.5; // Adjust as needed
            const sphere = new THREE.Sphere(cameraPosition, collisionSphereRadius);
            let collision = false;

            for (let i = 0; i < objects.length; i++) {
                const boundingBox = new THREE.Box3().setFromObject(objects[i]);
                if (boundingBox.intersectsSphere(sphere)) {
                    collision = true;
                    break;
                }
            }

            if (collision) {
                // Revert to the old position if collision detected
                controls.getObject().position.copy(oldPosition);
                velocity.set(0, 0, 0);
            }

            prevTime = time;
        }

        renderer.render(scene, camera);
    }

    function createWall(x, y, z, width, height, depth, wallTexture) {
        const wallGeometry = new THREE.BoxGeometry(width, height, depth);
        const wallMaterial = new THREE.MeshPhongMaterial({ map: wallTexture });
        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
        wall.position.set(x, y, z);
        scene.add(wall);
        objects.push(wall);
    }

    function addRandomWall(material, height) {
        const wallThickness = 0.2;
        const wallLength = Math.floor(Math.random() * 30) + 20; // Random length between 20 and 50
        const isVertical = Math.random() < 0.5;

        const wallGeometry = isVertical
            ? new THREE.BoxGeometry(wallThickness, height, wallLength)
            : new THREE.BoxGeometry(wallLength, height, wallThickness);

        const wall = new THREE.Mesh(wallGeometry, material);

        // Position within bounds
        const x = Math.floor(Math.random() * 80) - 40; // Random x between -40 and 40
        const z = Math.floor(Math.random() * 80) - 40; // Random z between -40 and 40
        wall.position.set(x, height / 2, z);

        // Simple overlap check (optional)
        const wallBoundingBox = new THREE.Box3().setFromObject(wall);
        for (let i = 0; i < objects.length; i++) {
            const otherBoundingBox = new THREE.Box3().setFromObject(objects[i]);
            if (wallBoundingBox.intersectsBox(otherBoundingBox)) {
                // Overlaps with existing wall, skip adding this wall
                return;
            }
        }

        scene.add(wall);
        objects.push(wall);
    }
</script>
</body>
</html>
